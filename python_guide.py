# -*- coding: utf-8 -*-
"""Python Guide

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sdhKs0xhqbKUEDcFqFv93tyJONfcOJwv

# Python Essentials
## A Guide on Functional Programming with Python

### Introduction
This guide is written in hope that it contains enough information on Python programming for a beginner to learn the language and to write functional codes quickly, and a quick-reference guide for the more experienced.

### Python Version
All code examples are written in Python 3. 

### Notebook and Colaboratory
This notebook is written with Google's [Colaboratory](https://colab.research.google.com/). A Google account is required for access and creating notebooks, but it is a powerful tool to learn Python without installing any programming onto the computer. Similar products are Jupyter notebooks (by Anaconda).

### Some notes on writing "Pythonic" codes
Codes written should be what the community calls "Pythonic". The Zen of Python (below) summarises what is meant by a "pythonic" code.
"""

import this

"""## Topics
The following is the minimum requirement to write a functional code and will be covered in this guide:
- Data Types
- Data Structures
- Functions
- Loop and Iterations
- Importing and Using Packages

### Some notes on Classes, Attributes and Methods
Python is a object-orientated programming (OOP) language. The definition of an OOP is ubiquitous in the Internet and can be found easily with a Google search. In Python, objects are created using _classes_. This is the most powerful feature in Python because Python classes are supposedly very easy to write. Unfortunately this topic is not covered in much extent because the aim of this section is to introduce the idea of Attributes and Methods, which are components of a class, depending on how they are defined. Consider the following example:
"""

class Square():
    def __init__(self, L):
      self.Length = L
      self.Area = L**2
    def perimeter(self):
      return 4*self.Length

"""The simple code above defines a class (object) call "Square". The first ```def``` line defines the behaviour when initializing the class. The subsequent two lines that follow define the Length and Area of the object Square respectively. These are the **attributes** of the object and are usually in the form ```Class.Attribute```.

The second ```def``` code is a function that resides within the class to calculate other properties. This function can be invoke by calling out the class. Such a function is call a **method** and is usually in the form ```Class.Method()``` - note the parentheses.

The following codes shows how it is used.
"""

# First, initialize a square S with length of 2 units. Note that there is no need to declare the "self" variable.
S = Square(2)

# We can check the length of the square by checking its attributes
# Checking the length attribute - 2 is expected.
S.Length

# Checking the area attribute - 4 is expected.
S.Area

# Now, we can calculate the perimeter using the "Perimeter" method.
S.perimeter()

"""Classes are the building blocks of many powerful packages. Distinguishing between attributes and methods will help with optimizing the utility of the packages.

##Data Types

The common data types are *Integer, Float, String and Boolean.*

###Integers
Integers are whole numbers (0, 1, 2, 3, 4, ...). They are also used as counters in a loop/iteration.

###Floats
Floats are decimal numbers (0.1, 0.2, 0.3, 0.9, ...). They are numerical representation of measurements.

###Strings
Strings are characters ("A", "a", "WORLD123", "hello"). Note that a string is bounded by quotation marks. A number that is bounded by a quotation marks is a string.

###Booleans
Booleans are True or False. Numerically, True = 1 and False = 0.


---


Some data structures (to be covered shortly) have data types considerations. That is, some data structures require that the data are of the same type, whereas some do not. Fortunately, Python is "smart" enough to distinguish the data type in most cases.
"""

print("An example of a Integer:")
print(1, type(1))
print("\nAn example of a Float:")
print(2.0, type(2.0))
print("\nAn example of a String:")
print("hello", type("hello"))
print("\nAn example of a Boolean:")
print(True, type(True))
print("\nNumerical value of True:")
print(int(True))

"""##Data Structures
Data structure determines how data are stored, which affects the speed of processing such as sorting and searching (this has to do with algorithms design, which is beyond the scope of this guide). The common data structures are *List, Dictionaries and Tuples*. Each have their own features that should be considered.

###List
A list is a collection of data with index. In Python, a list is defined by enclosing the data within a pair of square brackets. Data are indexed (or numbered if you will) sequentially.
Lists are commonly used in iterations/loops, as shown in the following code.
"""

# Define a list
lst = [1,2,3,4,5,6]

print(type(lst))

"""Lists are indexed and the indices can be called out using the index-method(```.index()```). Suppose we want to find out the index of 4 in the list. Expect result  is 3. (Remember that Python is 0-indexed)."""

lst.index(4)

"""####Manipulating Lists
- Lists can be appended
- Lists can be sliced/diced using index
- Multiple lists can be added to form a bigger one
"""

print('Appending a list:')
print(lst)
lst.append(7)
print(lst)

print("Slicing/Dicing a list:")
print("Slice index 1 to 3 excluded:")
print("Expected: [2, 3]")
print("Results: ", lst[1:3])
print("Note that Index-3 is excluded")

print("\nSlice first 3 elements")
print("Expected: [1, 2, 3]")
print("Results: ", lst[:3])

print("\nSlice last 3 elements")
print("Expected: [5, 6, 7]")
print("Results: ", lst[-3:])

"""*Note:* Only the basic slicing and dicing of a list is discussed here. There are actually many more tricks that can be deployed, and can be found in more extensive guides."""

print("Adding Lists")
lstA = [1,2,3,4,5]
lstB = [6,7,8,9,0]
lstC = lstA + lstB
print(lstC)

"""**TIP:** A fast way to create a list is to use the split method on a string containing the data. For example, creating a list that contains the number 1 to 5."""

# Create a string with the data
str = '1,2,3,4,5'
# Use the split method on the string
splt = str.split(',')
print(splt)

"""####List Comprehension
Notice that while the list is created, the elements are of data type string. To convert the elements to numerals, list comprehension can be used. List comprehension is an important feature in Python that allows manipulation of list quickly, without too much iteration or creating too many redundant lists in the process. 

The syntax for list comprehension is:
```
[i for i in list]
```
List comprehension is essentially a iteration but operated within a list. The output is a list. Each element in the list *list*  is represented by ```i```. ```for i in list``` hence means "for each element in list". the first ```i``` in the list comprehension is the operation that is applied on the element. In the code that follows, each element in the list ```splt``` is converted to an integer (```int()```). If no operation is specified, the list comprehension simply replicates the list.
"""

# List Comprehension
numLst = [int(i) for i in splt]

print(numLst)

"""####Sorting A List
To sort a list, use ```sorted()```. List are sorted in ascending order by default.
"""

lst = [1, 3, 2, 5, 4]
lst_sorted = sorted(lst)
lst_descend = sorted(lst, reverse=True)

print("The list: ", lst)
print("The sorted list with defaults: ", lst_sorted)
print("The list sorted in descending order: ", lst_descend)

"""Do note that, however, the indices of the elements in the list may be changed when the list is sorted, especially when working with dataframes using the *sort_by* method. More on this later.  Using the *sorted* method does not have the indices problem. This can be easily verified."""

for i in lst_sorted:
    print(lst_sorted.index(i))

"""### Dictionaries
Dictionaries use harshing to store data for efficient searching. A dictionary stores *keys* of data, which in turn store the *values* of the data. The keys and values of a dictionary are collectively called *items*. Dictionaries are defined by bounding the data using curly braces { ... }  and has the form: ```{keys : values}```. Note that ```values``` can be any datatype - a list, tuple, a dataframe or even another dictionary.

Here's an example and some flavour of a dictionary.
"""

# Define a dictionary
exDict = {"a" : [1,2,3,4], "b": "hello", "c": (4,5,6,7)}

print("Dictionary items: ", exDict.items())
print("Dictionary keys: ", exDict.keys())
print("Dictionary values: ", exDict.values())

"""Note that the information that the dictionary stores (items, keys, values) are called out using the respective methods. Also, the output is a dictionary object, which can be easily converted to a list using a *list()* method (not shown here).

A syntax similar to list slicing is used to call out the individual components in the dictionary. For example, to call out item "a" in the dictionary we use 
```
exDict["a"]
```
Since key "a" stores a list, the output will be a list, which can be further manipulated with list operations discussed previously.
"""

print(exDict["a"])

# Define a variable A to have the values stored in key "a" of the dictionary
A = exDict["a"]

# Recall that variable A will be a list. Obtain the value in index 3 of a; expect 4.
A[3]

"""Note the following about dictionaries:
- Dictionaries are mutable. That is, new keys can be added. Values can be changed. 
- Dictionaries are not iterable - an iteration can be performed over a dictionary. However, the keys and values can be, depending on their respective data types of course.
- Dictionaries do not have an index, hence keys may not have any order when printed.

---

Dictionaries are useful in storing and segregating processed data. An example would be storing the optimal allocation/configuration after an optimization is performed on the data.

Here's an example to segregate even and odd numbers.
"""

numbers = list(range(10))
# range(10) returns 10 integers starting from 0.
# "list" method returns a list of numbers 0 to 9.
numbers

# Define a dictionary
num = {"even":[], "odd":[]}

# Iterate over "numbers" and allocate the number to key "even" if it is an even number
# or key "odd" otherwise

for i in numbers:
    if i%2 == 0:
        # % here is "modulo" that is it returns the remainder of a division
        num["even"].append(i)
    else:
        num["odd"].append(i)
        
num

"""###Tuples
- Data are stored within a bracket ( ... ) in a tuple.
- Like lists, data are indexed, meaning elements of a tuple can be called out using index slicing
- However, tuples are immutable. No new item can be added.
- Tuples can be "unpacked" - a number of variables equal to the number of elements in the tuple can be defined simultaneously. This makes it useful for functions with multiple value returns, as we shall see later. (A list can be unpacked too. But the fact that tuples are immutable makes unpacking have more utility because the number of the elements in a list may change, whereas a tuple, will not).
"""

tup = (1, 2, 3, 4, 5)
tup[2] # Expect: 3

# Tuple Unpacking
a, b, c, d, e = tup

print("a = ", a)
print("b = ", b)
print("c = ", c)
print("d = ", d)
print("e = ", e)

"""###Dataframes
- Dataframes (or *df*) is data presented in a tabular form, like a spreadsheet. Its columns are theparameters and the rows are the corresponding measurements/observations.
- Dataframes are commonly used in data analysis. 
- The pandas library is commonly used to create and manipulate dataframes.
    - It allows various form of data files - csv, txt, excel, and even querying from a relational (SQL) database.
    - It can also create pivot tables and plots. 
    - Pandas also allow joining and merging of tables.
 
- Dataframe manipulation is a very broad topic, and it is beyond the scope of this guide. Regardless, it is a must-have tool any serious data analyst using Python. The [pandas documentation](https://pandas.pydata.org/) page is a good place to start learning about the library.

## Functions
Functions can be defined to make iterative computations or operations easy. Functions can also make the code easier to read and debug.
The syntax of a function in Python is
```
def FunctionName(Parameters):
    <Function body - Operations involving Parameters stated>
    return <Output from the Operations>
```
Remember that Python is sensitive to white spaces and the indentation after the ```def``` line is required. Otherwise, an error will occur.

---

Here's an example of a function to determine if a number is even or not.
"""

# Define the function
def EvenOrNot(n):
    if n%2 == 0:
        print("The number is even")
    else:
        print("The number is not even")

# Test if 3 is even
EvenOrNot(3)

"""Notice the missing *return* line in the function definition? It is deliberately left out. While it may not be a good practice, the return line is not required if the funciton is not expected to return any value for computation.

### Returning multiple values - using tuple unpacking
If a function returns multiple values, we can use tuple unpacking to get the results. Here's an example function that returns the square and cube of a number.
"""

def sqCube(n):
    return n**2, n**3

sq, cb = sqCube(3)
print("Expected: 9, Result: ", sq)
print("Expected: 27, Result: ", cb)

"""##Conditions
One of the aims of coding is to make the programme perform some tasks. Conditional statements will be stated and certain specific tasks will be performed when those conditions are met. In Python, the syntax for a single condition statement is
```
if <condition 1>:
    <task if condition 1 is met>
else:
    <task if condition 1 is not met>
```

The ```else``` statement is not necessary if there is no action required when the condition stated is not met.

For nested conditions, the syntax is
```
if <condition 1>:
    <task if condition 1 is met>
elif <condition 2>:
    <task if condition 2 is met>
elif <condition 3>:
    <task if condition 3 is met>
else:
    <task if no condition is met>
```

```elif``` is "else if" in some other programming language like VBA.

The conditional statements are used in some of the examples. Try reviewing the material discussed so far and see if you can spot the use of conditional statements.

##Loops

Computers excel in iterative operations and computations, and almost all, if not all, programming languages have provision to perform iterations, or loops. There are generally two kinds of loops - the while-loop and the for-loop. 

The while-loop is conditional; the iteration will continue as long as some conditions are met. 

```
while <condition>:
    <task when condition is met>
```
Use while-loops with caution because it might get into a infinite operation if the end conditions are not set. The following will result in a infinite loop (do not try):

```
while True:
    print("hello")
```

The above simply states that if the condition is ```True```, print "hello". The result is an infinite printouts of "hello".

The following code shows an example of a functioning while-loop to print a text 5 times. Notice some kind of counter is required and the counter is required to be changed accordingly depending on how the conditions are set.
"""

c = 5
while c > 0:
    print("hello")
    # Ending condition
    c += -1

"""The for-loop performs operations over a range of items (a counter, for example). 
```
for <counter> in <range/list>:
    <tasks to be performed>
```
There are two variations of the for-loop. The first is to iterate over a range of numbers, usually the number of items to be iterated over, usually collected in a list.

```
for c in range(len(a_list)):
    print(c)
```

```c``` takes a numerical value corespondig to the index of the list in this case.

The second approach is to iterate over the items in a collection, usually a list.


```
for z in a_list:
    print(z)
```

In this case, ```z``` takes the value of the item in the list.

The following codes show the two variations in action.
"""

# Create a list
a_list = 'apple,banana,carrot,durian'.split(',')
a_list

# Iterate over the number of items in the list
for i in range(len(a_list)):
    print(i, a_list[i])

# Iterate over the items in the list
for i in a_list:
    print(i)

"""Using ```range(len(a_list))``` is not Pythonic. A preferred way is to use the ```enumerate()``` method, which returns a tuple of the index of an item and the item. In this case, the tuple is required to be unpacked - two counters are required instead of one."""

for idx, item in enumerate(a_list):
    print(idx, item)
    # The result is similar to the example above, but it is easier to read.

"""## Putting It Altogether

The above topics will now allow you to write a functional code. We shall go through a simple optimization problem.

### A Case Study - Maximizing variety with a fixed budget

Suppose that you have a budget, *B*, and you would like to spend on the following items:
1. Pencil (0.50 each, utility = 0.6)
2. Pen (0.80 each, utility = 0.8)
3. Ruler (0.60 each, utility = 0.2)
4. Eraser (0.30 each, utility = 0.4)

Utility is the measure of usefulness. The problem is to maximise utility with the given budget, subject to the constraint that
- The maximum number of eraser you can buy is 10
- The amount left over must be minimum.
- Suppose *B* = 10

The approach used here is optimizing via simulation, a simpler version of dynamic programming. As with all simulation, randomness needs to be introduced to allow random choice.

The following code should address the problem. Refer to the comments on the intuition to each step of the code.
"""

import numpy as np
np.random.seed(168)

B = 10

things = 'pencil,pen,ruler,eraser'.split(',')
pr = [0.5, 0.8, 0.6, 0.3]
ut = [0.6, 0.8, 0.2, 0.4]

def pick_items(t):
	idx = np.random.choice(range(len(t)))
	return idx, t[idx]
	
def add_to_bag(tg, pr, ut, B, constraint=['eraser', 3]):
	# tg = Things, pr= Price, ut = utility
	Ut = 0
	bal = B
	tg2 = tg
	minPr = min(pr)
	bag = {}
	
	# constraint
	tConstraint = constraint[0]
	nConstraint = constraint[1]
	ntrack = 0
	track1 = 0
	track2 = 0
	
	while (bal > minPr):
        
        # Continue to pick things as long as there is money to buy at least the lowest priced item.
		idx, itm = pick_items(tg2)
		
        # If the item picked result in a negative balance, pick again.
		while (bal - pr[idx] < 0):
			idx, itm = pick_items(tg2)
			track1 +=1
			
            # Set constraint to break infinite while loop
			if track1 == 500:
				break
		
		# If the above loop was stopped, check if the balance is negative. If so, break the outer while loop (forgo one iteration)
		if bal -pr[idx] <0:
			break
		
		Ut += ut[idx]
		bal += -pr[idx]
		
		# Add item to count tracker 
		if itm in bag:
			bag[itm] += 1
		else:
			bag[itm] = 1
		
		# Update constraint tracker
		if itm in tConstraint:
			ntrack += 1
			
			# remove constraint item if constraint is met
			if ntrack == nConstraint:
				tg2 = [i for i in tg if i != tConstraint]
				ntrack = 0
		
		track2 +=1
		if track2 == 500:
			break
		
	return bag, round(Ut, 3), round(bal, 3)
	
# Debug / Test
for i in range(10):
	print(i, add_to_bag(things, pr, ut, B=10, constraint = ['eraser', 3]))

"""Looks like the code for one simulation works. Now we can build another function to iterate the simulation above.
```
"""

def iter_add_to_bag(tg, pr, ut, B, constraint, iter=1000):
	maxU = 0
	maxBag = 0
	minB = 0
	maxBag_dict = {}
	
	for i in range(iter):
		bag1, ut1, B1 = add_to_bag(tg, pr, ut, B, constraint)
		
		if ut1 > maxU:
			maxBag_dict[str(i)]= [bag1, ut1, B1]
			maxU = ut1
			maxBag = bag1
			minB = B1
		elif ut1 == maxU:
			maxBag_dict[str(i)]= [bag1, ut1, B1]
	
	return maxU, maxBag, minB, maxBag_dict

# For Reporting

def print_report(con, maxBag, minB, maxBag_d):
    if con[0] in things:
        print(f'*** Combination with the most utility with constraint: maximum {con[1]} {con[0]} ***\n')
    else:
        print(f'*** Combination with the most utility with NO constraint ***\n')
    for keys in maxBag.keys():
        print(f'{keys} : {maxBag[keys]}')
    print(f'Utility = {maxU}, \tBudget Left = {minB}')
    print(f'\n*** Other Combinations ***\n')
    for keys1 in maxBag_d.keys():
        if maxBag_d[keys1][1] >= maxU:
            bagk = maxBag_d[keys1][0]
            for k in bagk.keys():
                print(f'{k} : {bagk[k]}')
            print(f'Utility = {maxBag_d[keys1][1]}, \tBudget Left = {maxBag_d[keys1][2]}\n')

"""We can now simulate over a number of iterations. By default we will do this 1000 times (imagine having to this repeatedly.. 1000 times!). In general, the more iterations, the better results will be produced, **but** at a higher computation costs. However, 1000 iterations can be easily managed by decent computer/internet connection. We will constraint buying more than 2 erasers."""

con = ['eraser', 2]

maxU, maxBag, minB, maxBag_d = iter_add_to_bag(things, pr, ut, B, con)

print_report(con, maxBag, minB, maxBag_d)

"""Since it is a simulation of picking and packing the items a number of times, there will be repeated combinations. And as expected, there will tend to have pens and pencils because we have more utility. If one is constraint, the other will increase. As shown below."""

con = ['pen', 2]

maxU, maxBag, minB, maxBag_d = iter_add_to_bag(things, pr, ut, B, con)

print_report(con, maxBag, minB, maxBag_d)

"""We ended up buying 11 pencils!

The following is the combination if there is NO constraints. Note that for unconstraint case, simply pass a string with no useful information, or pass an item not (or a variation of it)in the original 4.

We ended buying more erasers because they are cheap and the utility per dollar is quite high.
"""

con = ['', 0]

maxU, maxBag, minB, maxBag_d = iter_add_to_bag(things, pr, ut, B, con)

print_report(con, maxBag, minB, maxBag_d)

"""## Conclusion

This guide have  discussed the basic blocks of writing a functional code:
1. Data types and structures
2. Functions
3. Iterations/Loops

Here are some of the things to note (thought of on the fly while the above code was written):
- Always start with an end in mind. Map the steps (written or otherwise) before starting. Sometimes multiple steps will be involved and the steps may inter-link so the coding will get complicated. There you have it, an algorithm!
- Name variables meaningfully, it helps with debugging. Remember that variables cannot start with a number. e.g. 1vox is not allowed, but vox1 is.
- Sometimes performing simulation is better than doing statistical test or coming out with fancy mathematical model. If the relationship between variables are too complex to map, simulate! 
    - Statistics by simulation is called 'Hacker Statistics'. Because of the power of the modern CPU this branch of statistics is getting popular.

## Afterthought
The case study only looked at one constraints. Of course it is possible to have multiple constraints. Can you think of how to write it? However, with each added constraint it will require more conditions to be set. Nevertheless, we should always think how to make our code cleaner by asking 

>>> **Can we do better?**

### The End
R0: 2019-03-08
"""